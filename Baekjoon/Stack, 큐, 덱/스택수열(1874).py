# 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다.
# 이때, 스택에 push 하는 순서는 반드시 오름차순을 지키도록 한다.
# 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 
# 있다면 push 와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 

# [입력]
# 첫 줄에 n이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 
# 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.

# [출력]
# 입력된 수열을 만들기 위해 필요한 연산을 한줄에 한 개씩 출력한다. push 연산은 + 로,
# pop 연산은 - 
# 불가능한 경우 No를 출력한다.

# [예제 입력]    [예제 출력1]
# 8              +   
# 4              +   
# 3              +   
# 6              +  
# 8              - 
# 7              -
# 5              +
# 2              +
# 1              -

# 1,2,3,4    + + + +
# 1,2        - -    4,3
# 1,2,5,6    + +
# 1,2,5      -      6
# 1,2,5,7,8  + +
# x          - - - - -   8,7,5,2,1
# ----------------------------------------
stack = []  # 스택의 상태를 추적하기 위한 리스트
count = 1  # 스택에 넣을 다음 숫자를 추적하기 위한 변수
op = []  # 연산을 기록하기 위한 리스트('+': 넣기, '-': 빼기)

N = int(input())  # 연산의 수를 입력받음
for i in range(N):
    num = int(input())  # 스택 연산으로 맞춰야 하는 대상 숫자 입력받음
    
    # count가 num에 도달하거나 넘을 때까지 스택에 숫자를 넣음
    while count <= num:
        stack.append(count)
        op.append('+')  # 넣는 연산을 기록
        count += 1  # 다음에 넣을 숫자로 이동
    
    # 스택의 맨 위 숫자가 num과 동일할 때까지 스택에서 숫자를 빼기
    if stack[-1] == num:  # 스택의 맨 위가 우리가 원하는 숫자인 경우
        stack.pop()  # 스택에서 해당 숫자를 뺌
        op.append('-')  # 빼는 연산을 기록
    else:
        # 스택의 맨 위 숫자와 num이 동일하지 않다면, 해당 시퀀스는 불가능
        print("NO")
        break
else:  # 'for' 루프에 해당하는 'else', 루프가 'break' 없이 정상적으로 종료되었을 경우 실행
    # 모든 숫자에 대해 성공적으로 연산을 수행했다면, 연산의 순서를 출력
    for o in op:
        print(o)  